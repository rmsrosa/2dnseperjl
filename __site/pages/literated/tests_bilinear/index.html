<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="" />
  <meta name="author" content="and contributors" />
   <title>Approximations of the bilinear term</title>  
  <link rel="shortcut icon" type="image/png" href="/assets/images/favicon.png"/>
  <link rel="stylesheet" href="/css/base.css"/>
  
    <link rel="stylesheet" href="/css/base_showaside.css"/>
  
  <script src="/libs/mousetrap/mousetrap.min.js"></script>

  
    <link rel="stylesheet" href="/libs/highlight/github.min.css">
    <script src="/libs/highlight/highlight.pack.js"></script>
    <script src="/libs/highlight/julia.min.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', (event) => {
        document.querySelectorAll('pre').forEach((el) => {
          hljs.highlightElement(el);
        });
      });
    </script>
  

  
    <link rel="stylesheet" href="/libs/katex/katex.min.css">
  
</head>

<body>

  <div class="books-container">

  <aside class="books-menu">
  <input type="checkbox" id="menu">
  <label for="menu">☰</label>

  <div class="books-title">
    <a href="/">Two-dimensional periodic flows</a>
  </div>

  <br />

  <div class="books-subtitle">
    Pseudo-spectral simulation in Julia
  </div>

  <br />

  <div class="books-author">
    <a href="https://rmsrosa.github.io">Ricardo M. S. Rosa</a>
  </div>

  <div class="books-menu-content">
    <div class="menu-level-1">
    <li><a href="/pages/intro">Introduction</a></li>
    </div>
    <div class="menu-level-1">
    <li>1. Mathematical Formulation</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/pages/pressure-velocity">1.1. Pressure-velocity formulation</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/pages/vorticity">1.2. Vorticity formulation</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/pages/basdevant">1.3. Basdevant reduction</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/pages/stream">1.4. Stream function</a></li>
    </div>
    <div class="menu-level-1">
    <li>2. Spectral Formulation</li>
    </div>
    <div class="menu-level-1">
    <li>3. Discrete Fourier Transform</li>
    </div>
    <div class="menu-level-1">
    <li>4. Physical Quantities</li>
    </div>
    <div class="menu-level-1">
    <li>5. Two-dimensional turbulence</li>
    </div>
    <div class="menu-level-1">
    <li>6. FFTW Tests</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/pages/literated/tests_basic">6.1. Direct and inverse FFTW</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/pages/literated/tests_fft_plan">6.2. FFTW plans</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/pages/literated/benchmark_fft_plan">6.3. Benchmarking flags for FFTW plans</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/pages/literated/tests_bilinear">6.4. Approximations of the bilinear term</a></li>
    </div>
    <div class="menu-level-1">
    <li>7. Evolution Tests</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/pages/literated/tests_mol">7.1. Evolution via method of lines</a></li>
    </div>
    <div class="menu-level-1">
    <li>8. Simulations</li>
    </div>
    <div class="menu-level-1">
    <li><a href="/pages/references">9. References</a></li>
    </div>
<div>


  
    <a href="https://github.com/rmsrosa/2dnsepervortjl"><img src="/assets/images/GitHub-Mark-32px.png" alt="GitHub repo" width="18" style="margin:5px 5px" align="left"></a>

  

</aside>


  <div class="books-content">

    
      <div class="navbar">
    <p id="nav">
<span id="nav-prev" style="float: left;">
<a class="menu-level-1" href="/pages/literated/benchmark_fft_plan">6.3. Benchmarking flags for FFTW plans <kbd>←</kbd></a>
</span>
<span id="nav-next" style="float: right;">
    <a class="menu-level-1" href="/pages/literated/tests_mol"><kbd>→</kbd> 7.1. Evolution via method of lines</a>
</span>
    </p>
</div>
</br></br>

    

    
      <div class="badges">
<p>
<a href="https://nbviewer.org/urls/rmsrosa.github.io/2dnsepervortjl/generated/literated/tests_bilinear.ipynb"><img align="left" src="https://img.shields.io/badge/view%20in-nbviewer-orange" alt="View in NBViewer" title="View Jupyter notebook in NBViewer"></a>
<a href="https://mybinder.org/v2/gh/rmsrosa/2dnsepervortjl/binderenv?urlpath=git-pull%3Frepo%3Dhttps://github.com/rmsrosa/2dnsepervortjl%26urlpath%3Dlab/tree%252F2dnsepervortjl/generated/literated/tests_bilinear.ipynb%26branch%3Dgh-pages"><img align="left" src="https://mybinder.org/badge.svg" alt="Open in binder" title="Open in binder"></a>
<a href="/generated/literated/tests_bilinear.ipynb"><img align="left" src="https://img.shields.io/badge/download-notebook-blue" alt="Download notebook" title="Download Jupyter notebook"></a>
<a href="/src/literate/tests_bilinear.jl"><img align="left" src="https://img.shields.io/badge/view-source-lightblue" alt="View source" title="View source"></a>
</p>
</div></br>

    
<h1 id="get_title"><a href="#get_title" class="header-anchor">6.4. Approximations of the bilinear term</a></h1>
<p>Ultimately we want to evolve, in time, an equation of the form # </p>
\[
  \omega_t = G(\omega).
\]
<p>For the 2D NSE, \(G\) is of the form</p>
\[
 G(\omega) = g + \nu \Delta \omega + B(\omega),
\]
<p>where</p>
\[
  B(\omega) = \left(\partial_x^2 - \partial_y^2\right)(uv) + \partial_{xy}\left(v^2 - u^2\right),
\]
<p>with \(\mathbf{u} = (u(x, y), v(x, y))\) being the velocity field associated with the vorticity, i.e. \(\omega = \boldsymbol{\nabla} \times \mathbf{u} = v_x - u_y\).</p>
<p>In spectral space, \(\Delta \omega\) is just a diagonal operator, while \(g\) is a given scalar field, which are both easy to compute. The most computationally demanding term is \(B(\omega)\).</p>
<p>Here, we test different ways of approximating \(B(\omega)\).</p>
<p>The packages we are gonna need.</p>
<pre><code class="language-julia">using FFTW
using Plots
using LinearAlgebra: mul&#33;
using Test
using BenchmarkTools
using Random

@info &quot;Threads: &#36;&#40;FFTW.nthreads&#40;&#41;&#41;&quot;</code></pre>
<pre><code class="language-julia">&#91; Info: Threads: 8</code></pre>
<h2 id="operators"><a href="#operators" class="header-anchor">Operators</a></h2>
<p>We first define a method to build the various operators acting in spectral space:</p>
<pre><code class="language-julia">function get_operators&#40;N, κ₀&#41;
    # Differentiation in spectral space
    Dx_hat &#61; im * κ₀ * &#91;
        ifelse&#40;k1 ≤ div&#40;N, 2&#41; &#43; 1, k1 - 1, k1 - 1 - N&#41; for k2 in 1:div&#40;N, 2&#41;&#43;1, k1 in 1:N
    &#93;
    Dy_hat &#61; im * κ₀ * &#91;k2 - 1 for k2 in 1:div&#40;N, 2&#41;&#43;1, k1 in 1:N&#93;

    Delta_hat &#61; - κ₀^2 * &#91;
        ifelse&#40;k1 ≤ div&#40;N, 2&#41; &#43; 1, &#40;k1 - 1&#41;^2 &#43; &#40;k2 - 1&#41;^2, &#40;k1 - 1 - N&#41;^2 &#43; &#40;k2 - 1&#41;^2&#41;
        for k2 in 1:div&#40;N, 2&#41;&#43;1, k1 in 1:N
    &#93;

    # For the Basdevant formulation
    DxsqDysq_hat &#61; Dx_hat.^2 .- Dy_hat.^2
    Dxy_hat &#61; Dx_hat .* Dy_hat

    # Recovering of the velocity field from the vorticity
    Hu_hat &#61; - Dy_hat ./ Delta_hat
    Hu_hat&#91;1, 1&#93; &#61; 0.0
    Hv_hat &#61; Dx_hat ./ Delta_hat
    Hv_hat&#91;1, 1&#93; &#61; 0.0

    return Dx_hat, Dy_hat, Delta_hat, Hu_hat, Hv_hat, DxsqDysq_hat, Dxy_hat
end</code></pre>
<pre><code class="language-julia">get_operators &#40;generic function with 1 method&#41;</code></pre>
<h2 id="generation_of_a_scalar_field"><a href="#generation_of_a_scalar_field" class="header-anchor">Generation of a scalar field</a></h2>
<p>Method to generate a scalar field from a list of wavenumbers and amplitudes:</p>
<pre><code class="language-julia">function field_from_modes&#40;L, N, modes::Matrix&#123;&lt;:Integer&#125;, amps::Matrix&#123;&lt;:Real&#125;&#41;
    κ₀ &#61; 2π/L
    x &#61; y &#61; &#40;L/N&#41;:&#40;L/N&#41;:L
    field &#61; sum&#40;
        &#91;
            2κ₀^2 * &#40;k&#91;1&#93;^2 &#43; k&#91;2&#93;^2&#41; * &#40;
                a&#91;1&#93; * cos.&#40;κ₀ * &#40;k&#91;1&#93; * one.&#40;y&#41; * x&#39; &#43; k&#91;2&#93; * y * one.&#40;x&#41;&#39;&#41;&#41;
                - a&#91;2&#93; * sin.&#40;κ₀ * &#40;k&#91;1&#93; * one.&#40;y&#41; * x&#39; &#43; k&#91;2&#93; * y * one.&#40;x&#41;&#39;&#41;&#41;
            &#41;
            for &#40;k, a&#41; in zip&#40;eachrow&#40;modes&#41;, eachrow&#40;amps&#41;&#41;
        &#93;
    &#41;
    return field
end</code></pre>
<pre><code class="language-julia">field_from_modes &#40;generic function with 1 method&#41;</code></pre>
<p>Method to randomly generate a scalar field from a given random number generator and a given number wavenumbers to be excited:</p>
<pre><code class="language-julia">function field_from_modes&#40;rng::AbstractRNG, L, N, num_modes::Int&#41;

    modes &#61; rand&#40;rng, 1:div&#40;N,10&#41;, num_modes, 2&#41;
    amps &#61; rand&#40;rng, num_modes, 2&#41;

    field &#61; field_from_modes&#40;L, N, modes, amps&#41;

    return field
end</code></pre>
<pre><code class="language-julia">field_from_modes &#40;generic function with 2 methods&#41;</code></pre>
<p>Method to randomly generate a scalar field from a given number wavenumbers to be excited:</p>
<pre><code class="language-julia">field_from_modes&#40;L, N, num_modes::Int&#41; &#61; field_from_modes&#40;Xoshiro&#40;&#41;, L, N, num_modes&#41;</code></pre>
<pre><code class="language-julia">field_from_modes &#40;generic function with 3 methods&#41;</code></pre>
<h2 id="methods_for_computing_the_bilinear_term"><a href="#methods_for_computing_the_bilinear_term" class="header-anchor">Methods for computing the bilinear term</a></h2>
<pre><code class="language-julia">function bilinear_naive&#40;vort_hat, params&#41;
    operators, vars &#61; params

    Dx_hat, Dy_hat, Delta_hat, Hu_hat, Hv_hat,
        DxsqDysq_hat, Dxy_hat &#61; operators
    N, Nsub &#61; vars

    u_hat &#61; Hu_hat .* vort_hat
    v_hat &#61; Hv_hat .* vort_hat
    u &#61; irfft&#40;u_hat, N&#41;
    v &#61; irfft&#40;v_hat, N&#41;
    vort &#61; irfft&#40;vort_hat, N&#41;
    wu_hat &#61; rfft&#40;vort .* u&#41;
    wv_hat &#61; rfft&#40;vort .* v&#41;

    bilin_hat &#61; Dx_hat .* wu_hat .&#43; Dy_hat .* wv_hat
    # dealiasing
    bilin_hat&#91;div&#40;Nsub,2&#41; &#43; 1:end, :&#93; .&#61; 0.0im
    bilin_hat&#91;:, div&#40;Nsub,2&#41; &#43; 1:div&#40;N,2&#41; &#43; div&#40;Nsub,2&#41;&#93; .&#61; 0.0im
    return bilin_hat
end</code></pre>
<pre><code class="language-julia">bilinear_naive &#40;generic function with 1 method&#41;</code></pre>
<pre><code class="language-julia">function bilinear_auxs&#33;&#40;bilin_hat, vort_hat, params&#41;
    operators, vars, auxs &#61; params

    Dx_hat, Dy_hat, Delta_hat, Hu_hat, Hv_hat,
        DxsqDysq_hat, Dxy_hat &#61; operators
    N, Nsub &#61; vars
    u_hat, v_hat, u, v, w, wu, wv, wu_hat, wv_hat &#61; auxs

    u_hat .&#61; Hu_hat .* vort_hat
    v_hat .&#61; Hv_hat .* vort_hat
    u .&#61; irfft&#40;u_hat, N&#41;
    v .&#61; irfft&#40;v_hat, N&#41;
    w .&#61; irfft&#40;vort_hat, N&#41;
    wu .&#61; w .* u
    wv .&#61; w .* v
    wu_hat .&#61; rfft&#40;wu&#41;
    wv_hat .&#61; rfft&#40;wv&#41;

    bilin_hat .&#61; Dx_hat .* wu_hat .&#43; Dy_hat .* wv_hat
    # dealiasing
    bilin_hat&#91;div&#40;Nsub,2&#41; &#43; 1:end, :&#93; .&#61; 0.0im
    bilin_hat&#91;:, div&#40;Nsub,2&#41; &#43; 1:div&#40;N,2&#41; &#43; div&#40;Nsub,2&#41;&#93; .&#61; 0.0im

    return bilin_hat
end</code></pre>
<pre><code class="language-julia">bilinear_auxs&#33; &#40;generic function with 1 method&#41;</code></pre>
<pre><code class="language-julia">function bilinear_plan_brdcst&#33;&#40;bilin_hat, vort_hat, params&#41;
    operators, vars, auxs, plans &#61; params

    Dx_hat, Dy_hat, Delta_hat, Hu_hat, Hv_hat,
        DxsqDysq_hat, Dxy_hat &#61; operators
    N, Nsub &#61; vars
    u_hat, v_hat, u, v, w, wu, wv, wu_hat, wv_hat &#61; auxs
    plan, plan_inv &#61; plans

    u_hat .&#61; Hu_hat .* vort_hat
    v_hat .&#61; Hv_hat .* vort_hat
    mul&#33;&#40;u, plan_inv, u_hat&#41;
    mul&#33;&#40;v, plan_inv, v_hat&#41;
    # mul&#33; on inverse plan mutates last argument, but we need to preserve vort_hat
    # so, reuse v_hat for that:
    v_hat .&#61; vort_hat
    mul&#33;&#40;w, plan_inv, v_hat&#41;
    wu .&#61; w .* u
    wv .&#61; w .* v

    mul&#33;&#40;wu_hat, plan, wu&#41;
    mul&#33;&#40;wv_hat, plan, wv&#41;

    bilin_hat .&#61; Dx_hat .* wu_hat .&#43; Dy_hat .* wv_hat
    # dealiasing
    bilin_hat&#91;div&#40;Nsub,2&#41; &#43; 1:end, :&#93; .&#61; 0.0im
    bilin_hat&#91;:, div&#40;Nsub,2&#41; &#43; 1:div&#40;N,2&#41; &#43; div&#40;Nsub,2&#41;&#93; .&#61; 0.0im

    return bilin_hat
end</code></pre>
<pre><code class="language-julia">bilinear_plan_brdcst&#33; &#40;generic function with 1 method&#41;</code></pre>
<pre><code class="language-julia">function bilinear_Basdevant_brdcst&#40;vort_hat, params&#41;
    operators, vars &#61; params

    Dx_hat, Dy_hat, Delta_hat, Hu_hat, Hv_hat,
        DxsqDysq_hat, Dxy_hat &#61; operators
    N, Nsub &#61; vars

    u_hat &#61; Hu_hat .* vort_hat
    v_hat &#61; Hv_hat .* vort_hat
    u &#61; irfft&#40;u_hat, N&#41;
    v &#61; irfft&#40;v_hat, N&#41;
    uv_hat &#61; rfft&#40;u .* v&#41;
    v2u2_hat &#61; rfft&#40;v.^2 - u.^2&#41;

    bilin_hat &#61; DxsqDysq_hat .* uv_hat .&#43; Dxy_hat .* v2u2_hat
    # dealiasing
    bilin_hat&#91;div&#40;Nsub,2&#41; &#43; 1:end, :&#93; .&#61; 0.0im
    bilin_hat&#91;:, div&#40;Nsub,2&#41; &#43; 1:div&#40;N,2&#41; &#43; div&#40;Nsub,2&#41;&#93; .&#61; 0.0im

    return bilin_hat
end</code></pre>
<pre><code class="language-julia">bilinear_Basdevant_brdcst &#40;generic function with 1 method&#41;</code></pre>
<pre><code class="language-julia">function bilinear_Basdevant_plan_brdcst&#33;&#40;bilin_hat, vort_hat, params&#41;
    operators, vars, auxs, plans &#61; params

    Dx_hat, Dy_hat, Delta_hat, Hu_hat, Hv_hat,
        DxsqDysq_hat, Dxy_hat &#61; operators
    N, Nsub &#61; vars
    u_hat, v_hat, u, v, w, uv, v2u2, uv_hat, v2u2_hat &#61; auxs
    plan, plan_inv &#61; plans

    u_hat .&#61; Hu_hat .* vort_hat
    v_hat .&#61; Hv_hat .* vort_hat

    mul&#33;&#40;u, plan_inv, u_hat&#41;
    mul&#33;&#40;v, plan_inv, v_hat&#41;

    uv .&#61; u .* v
    v2u2 .&#61; v.^2 .- u.^2
    mul&#33;&#40;uv_hat, plan, uv&#41;
    mul&#33;&#40;v2u2_hat, plan, v2u2&#41;

    bilin_hat .&#61; DxsqDysq_hat .* uv_hat .&#43; Dxy_hat .* v2u2_hat

    # dealiasing
    bilin_hat&#91;div&#40;Nsub,2&#41; &#43; 1:end, :&#93; .&#61; 0.0im
    bilin_hat&#91;:, div&#40;Nsub,2&#41; &#43; 1:div&#40;N,2&#41; &#43; div&#40;Nsub,2&#41;&#93; .&#61; 0.0im

    return bilin_hat
end</code></pre>
<pre><code class="language-julia">bilinear_Basdevant_plan_brdcst&#33; &#40;generic function with 1 method&#41;</code></pre>
<pre><code class="language-julia">function bilinear_Basdevant_plan_loop&#33;&#40;bilin_hat, vort_hat, params&#41;
    operators, vars, auxs, plans &#61; params

    Dx_hat, Dy_hat, Delta_hat, Hu_hat, Hv_hat,
        DxsqDysq_hat, Dxy_hat &#61; operators
    N, Nsub &#61; vars
    u_hat, v_hat, u, v, w, uv, v2u2, uv_hat, v2u2_hat &#61; auxs
    plan, plan_inv &#61; plans

    @inbounds for k in eachindex&#40;u_hat&#41;
        u_hat&#91;k&#93; &#61; Hu_hat&#91;k&#93; * vort_hat&#91;k&#93;
        v_hat&#91;k&#93; &#61; Hv_hat&#91;k&#93; * vort_hat&#91;k&#93;
    end

    mul&#33;&#40;u, plan_inv, u_hat&#41;
    mul&#33;&#40;v, plan_inv, v_hat&#41;

    @inbounds for k in eachindex&#40;u&#41;
        uv&#91;k&#93; &#61; u&#91;k&#93; * v&#91;k&#93;
        v2u2&#91;k&#93; &#61; v&#91;k&#93;^2 - u&#91;k&#93;^2
    end

    mul&#33;&#40;uv_hat, plan, uv&#41;
    mul&#33;&#40;v2u2_hat, plan, v2u2&#41;

    @inbounds for k in eachindex&#40;vort_hat&#41;
        bilin_hat&#91;k&#93; &#61; DxsqDysq_hat&#91;k&#93; * uv_hat&#91;k&#93; &#43; Dxy_hat&#91;k&#93; * v2u2_hat&#91;k&#93;
    end
    # dealiasing
    @inbounds for j in 1:N, i in div&#40;Nsub,2&#41; &#43; 1:div&#40;N, 2&#41; &#43; 1
        bilin_hat&#91;i, j&#93; &#61; 0.0im
    end
    @inbounds for j in div&#40;Nsub,2&#41; &#43; 1:div&#40;N,2&#41; &#43; div&#40;Nsub,2&#41;, i in 1:div&#40;N, 2&#41; &#43; 1
        bilin_hat&#91;i, j&#93; &#61; 0.0im
    end

    return bilin_hat
end</code></pre>
<pre><code class="language-julia">bilinear_Basdevant_plan_loop&#33; &#40;generic function with 1 method&#41;</code></pre>
<pre><code class="language-julia">function bilinear_Basdevant_plan_doubleloop&#33;&#40;bilin_hat, vort_hat, params&#41;
    operators, vars, auxs, plans &#61; params

    Dx_hat, Dy_hat, Delta_hat, Hu_hat, Hv_hat,
        DxsqDysq_hat, Dxy_hat &#61; operators
    N, Nsub &#61; vars
    u_hat, v_hat, u, v, w, uv, v2u2, uv_hat, v2u2_hat &#61; auxs
    plan, plan_inv &#61; plans

    M, N &#61; size&#40;vort_hat&#41;

    @inbounds for j in 1:N, i in 1:M
        u_hat&#91;i, j&#93; &#61; Hu_hat&#91;i, j&#93; * vort_hat&#91;i, j&#93;
        v_hat&#91;i, j&#93; &#61; Hv_hat&#91;i, j&#93; * vort_hat&#91;i, j&#93;
    end

    mul&#33;&#40;u, plan_inv, u_hat&#41;
    mul&#33;&#40;v, plan_inv, v_hat&#41;

    @inbounds for j in 1:N, i in 1:N
        uv&#91;i, j&#93; &#61; u&#91;i, j&#93; * v&#91;i, j&#93;
        v2u2&#91;i, j&#93; &#61; v&#91;i, j&#93;^2 - u&#91;i, j&#93;^2
    end

    mul&#33;&#40;uv_hat, plan, uv&#41;
    mul&#33;&#40;v2u2_hat, plan, v2u2&#41;

    @inbounds for j in 1:N, i in 1:M
        bilin_hat&#91;i, j&#93; &#61; DxsqDysq_hat&#91;i, j&#93; * uv_hat&#91;i, j&#93; &#43; Dxy_hat&#91;i, j&#93; * v2u2_hat&#91;i, j&#93;
    end
    # dealiasing
    @inbounds for j in 1:N, i in div&#40;Nsub,2&#41; &#43; 1:M
        bilin_hat&#91;i, j&#93; &#61; 0.0im
    end
    @inbounds for j in div&#40;Nsub,2&#41; &#43; 1:div&#40;N,2&#41; &#43; div&#40;Nsub,2&#41;, i in 1:M
        bilin_hat&#91;i, j&#93; &#61; 0.0im
    end

    return bilin_hat
end</code></pre>
<pre><code class="language-julia">bilinear_Basdevant_plan_doubleloop&#33; &#40;generic function with 1 method&#41;</code></pre>
<h2 id="the_spatial_domain_and_its_discretization"><a href="#the_spatial_domain_and_its_discretization" class="header-anchor">The spatial domain and its discretization</a></h2>
<pre><code class="language-julia">L &#61; 2π
κ₀ &#61; 2π/L
N &#61; 256
Nsub &#61; 162
x &#61; y &#61; &#40;L/N&#41;:&#40;L/N&#41;:L</code></pre>
<pre><code class="language-julia">0.02454369260617026:0.02454369260617026:6.283185307179586</code></pre>
<h2 id="preparation_for_tests"><a href="#preparation_for_tests" class="header-anchor">Preparation for tests</a></h2>
<pre><code class="language-julia">Dx_hat, Dy_hat, Delta_hat, Hu_hat, Hv_hat, DxsqDysq_hat, Dxy_hat &#61; get_operators&#40;N, κ₀&#41;

vort &#61; field_from_modes&#40;L, N, 48&#41;
vort_hat &#61; rfft&#40;vort&#41;

u_hat &#61; similar&#40;vort_hat&#41;
v_hat &#61; similar&#40;vort_hat&#41;
u &#61; similar&#40;vort&#41;
v &#61; similar&#40;vort&#41;
w &#61; similar&#40;vort&#41;
uv &#61; similar&#40;vort&#41;
v2u2 &#61; similar&#40;vort&#41;
uv_hat &#61; similar&#40;vort_hat&#41;
v2u2_hat &#61; similar&#40;vort_hat&#41;
bilin_hat &#61; similar&#40;vort_hat&#41;

plan &#61; plan_rfft&#40;vort, flags&#61;FFTW.MEASURE&#41;
plan_inv &#61; plan_irfft&#40;vort_hat, N, flags&#61;FFTW.MEASURE&#41;

operators &#61; Dx_hat, Dy_hat, Delta_hat, Hu_hat, Hv_hat, DxsqDysq_hat, Dxy_hat
vars &#61; N, Nsub
auxs &#61; u_hat, v_hat, u, v, w, uv, v2u2, uv_hat, v2u2_hat
plans &#61; plan, plan_inv</code></pre>
<pre><code class="language-julia">&#40;FFTW real-to-complex plan for 256×256 array of Float64
&#40;rdft2-rank&gt;&#61;2/1
  &#40;rdft2-ct-dit/4
    &#40;hc2c-direct-4/6/0-x256 &quot;hc2cfdftv_4_sse2&quot;
      &#40;rdft2-r2hc-direct-4 &quot;r2cf_4&quot;&#41;
      &#40;rdft2-r2hc01-direct-4 &quot;r2cfII_4&quot;&#41;&#41;
    &#40;dft-vrank&gt;&#61;1-x256/1
      &#40;dft-direct-64-x2 &quot;n2fv_64_sse2&quot;&#41;&#41;&#41;
  &#40;dft-vrank&gt;&#61;1-x129/1
    &#40;dft-ct-dit/16
      &#40;dftw-direct-16/60 &quot;t2fv_16_sse2&quot;&#41;
      &#40;dft-indirect-before
        &#40;dft-direct-16-x16 &quot;n1fv_16_sse2&quot;&#41;
        &#40;dft-r2hc-1
          &#40;rdft-rank0-ip-sq/2-x16-x16&#41;&#41;&#41;&#41;&#41;&#41;, 1.52587890625e-5 * FFTW complex-to-real plan for 129×256 array of ComplexF64
&#40;rdft2-rank&gt;&#61;2/1
  &#40;rdft2-vrank&gt;&#61;1-x256/1
    &#40;rdft2-ct-dif/4
      &#40;hc2c-direct-4/6/0 &quot;hc2cbdft2_4&quot;
        &#40;rdft2-hc2r-direct-4 &quot;r2cb_4&quot;&#41;
        &#40;rdft2-hc2r10-direct-4 &quot;r2cbIII_4&quot;&#41;&#41;
      &#40;dft-direct-64-x2 &quot;n1bv_64_sse2&quot;&#41;&#41;&#41;
  &#40;dft-vrank&gt;&#61;1-x129/1
    &#40;dft-ct-dit/16
      &#40;dftw-direct-16/60 &quot;t2bv_16_sse2&quot;&#41;
      &#40;dft-indirect-before
        &#40;dft-direct-16-x16 &quot;n1bv_16_sse2&quot;&#41;
        &#40;dft-r2hc-1
          &#40;rdft-rank0-ip-sq/2-x16-x16&#41;&#41;&#41;&#41;&#41;&#41;&#41;</code></pre>
<h2 id="check_results"><a href="#check_results" class="header-anchor">Check results</a></h2>
<p>As a first test, we check that all implementations return about the same vector</p>
<pre><code class="language-julia">@testset &quot;same result bilinear terms&quot; begin

    bilin_hat_naive &#61; bilinear_naive&#40;
        vort_hat,
        &#40;operators, vars&#41;
    &#41;

    bilinear_hat_brdcst &#61; similar&#40;vort_hat&#41;
    bilinear_auxs&#33;&#40;bilinear_hat_brdcst, vort_hat, &#40;operators, vars, auxs&#41;&#41;

    bilin_hat_plan_brdcst &#61; similar&#40;vort_hat&#41;
    bilinear_plan_brdcst&#33;&#40;
        bilin_hat_plan_brdcst,
        vort_hat,
        &#40;operators, vars, auxs, plans&#41;
    &#41;

    bilin_hat_Basdevant_brdcst &#61; bilinear_Basdevant_brdcst&#40;
        vort_hat,
        &#40;operators, vars&#41;
    &#41;

    bilin_hat_Basdevant_plan_brdcst &#61; similar&#40;vort_hat&#41;
    bilinear_Basdevant_plan_brdcst&#33;&#40;
        bilin_hat_Basdevant_plan_brdcst,
        vort_hat,
        &#40;operators, vars, auxs, plans&#41;
    &#41;

    bilin_hat_Basdevant_plan_loop &#61; similar&#40;vort_hat&#41;
    bilinear_Basdevant_plan_loop&#33;&#40;
        bilin_hat_Basdevant_plan_loop,
        vort_hat,
        &#40;operators, vars, auxs, plans&#41;
    &#41;

    bilin_hat_Basdevant_plan_doubleloop &#61; similar&#40;vort_hat&#41;
    bilinear_Basdevant_plan_doubleloop&#33;&#40;
        bilin_hat_Basdevant_plan_doubleloop,
        vort_hat,
        &#40;operators, vars, auxs, plans&#41;
    &#41;

    @test bilin_hat_naive ≈ bilinear_hat_brdcst
    @test bilinear_hat_brdcst ≈ bilin_hat_plan_brdcst
    @test bilin_hat_plan_brdcst ≈ bilin_hat_Basdevant_brdcst
    @test bilin_hat_Basdevant_brdcst ≈ bilin_hat_Basdevant_plan_brdcst
    @test bilin_hat_Basdevant_plan_brdcst ≈ bilin_hat_Basdevant_plan_loop
    @test bilin_hat_Basdevant_plan_loop ≈ bilin_hat_Basdevant_plan_doubleloop
end
nothing</code></pre>
<pre><code class="language-julia">Test Summary:              | Pass  Total
same result bilinear terms |    6      6</code></pre>
<h2 id="orthogonality"><a href="#orthogonality" class="header-anchor">Orthogonality</a></h2>
<p>As a second test, we check the orthogonality condition of the bilinear term.</p>
<p>Due to the periodicity and the divergence-free conditions, we should have \((B(\omega), \omega)_{L^2} = 0\). We compute \(B(\omega)\) in spectral space and transform it to physical space in order to check that.</p>
<pre><code class="language-julia">bilin_hat_naive &#61; bilinear_naive&#40;vort_hat, &#40;operators, vars&#41;&#41;
bilin_naive &#61; irfft&#40;bilin_hat_naive, N&#41;
nothing</code></pre>
<p>We compute the inner product by summing over the nodal values and multiplying that by the area element \(\Delta x \Delta y = (L/N)^2\). Notice computing the inner product as such has an inherent numerical error, which is also of the order of the area element, so we don&#39;t expect the output to be of machine precision.</p>
<pre><code class="language-julia">sum&#40;bilin_naive .* vort&#41; * &#40;L / N&#41;^2</code></pre>
<pre><code class="language-julia">-3.5296455864033787e-6</code></pre>
<p>In spectral space, due to Parseval&#39;s identity, this translates to the following &#40;except we need to correct for some indices...&#41;</p>
<pre><code class="language-julia">M &#61; iseven&#40;N&#41; ? div&#40;N, 2&#41; : div&#40;N, 2&#41; &#43; 1

&#40;
    2 * sum&#40;bilin_hat_naive&#91;2:M,:&#93; .* conj.&#40;vort_hat&#91;2:M,:&#93;&#41;&#41;
    &#43; sum&#40;bilin_hat_naive&#91;1,:&#93; .* conj.&#40;vort_hat&#91;1,:&#93;&#41;&#41;
    &#43; sum&#40;bilin_hat_naive&#91;M&#43;1:end,:&#93; .* conj.&#40;vort_hat&#91;M&#43;1:end,:&#93;&#41;&#41;
&#41; / N^2 * &#40;L / N&#41;^2</code></pre>
<pre><code class="language-julia">-7.17626660933107e-6 &#43; 9.440994952260796e8im</code></pre>
<p>Hmm, something is wrong...</p>
<h2 id="benchmark"><a href="#benchmark" class="header-anchor">Benchmark</a></h2>
<pre><code class="language-julia">@info &quot;bilinear_naive&quot;
@btime bilinear_naive&#40;vh, p&#41; setup &#61; &#40;vh &#61; copy&#40;&#36;vort_hat&#41;; p &#61; &#36;&#40;operators, vars&#41;&#41;;

@info &quot;bilinear_auxs&#33;&quot;
@btime bilinear_auxs&#33;&#40;bh, vh, p&#41; setup &#61; &#40;bh &#61; similar&#40;&#36;vort_hat&#41;; vh &#61; copy&#40;&#36;vort_hat&#41;; p &#61; &#36;&#40;operators, vars, auxs, plans&#41;&#41;;

@info &quot;bilinear_Basdevant_brdcst&quot;
@btime bilinear_Basdevant_brdcst&#40;vh, p&#41; setup &#61; &#40;vh &#61; copy&#40;&#36;vort_hat&#41;; p &#61; &#36;&#40;operators, vars&#41;&#41;;

@info &quot;bilinear_plan_brdcst&#33;&quot;
@btime bilinear_plan_brdcst&#33;&#40;bh, vh, p&#41; setup &#61; &#40;bh &#61; similar&#40;&#36;vort_hat&#41;; vh &#61; copy&#40;&#36;vort_hat&#41;; p &#61; &#36;&#40;operators, vars, auxs, plans&#41;&#41;;

@info &quot;bilin_hat_Basdevant_plan_brdcst&#33;&quot;
@btime bilinear_Basdevant_plan_brdcst&#33;&#40;bh, vh, p&#41; setup &#61; &#40;bh &#61; similar&#40;&#36;vort_hat&#41;; vh &#61; copy&#40;&#36;vort_hat&#41;; p &#61; &#36;&#40;operators, vars, auxs, plans&#41;&#41;;

@info &quot;bilinear_Basdevant_plan_loop&#33;&quot;
@btime bilinear_Basdevant_plan_loop&#33;&#40;bh, vh, p&#41; setup &#61; &#40;bh &#61; similar&#40;&#36;vort_hat&#41;; vh &#61; copy&#40;&#36;vort_hat&#41;; p &#61; &#36;&#40;operators, vars, auxs, plans&#41;&#41;;

@info &quot;bilinear_Basdevant_plan_doubleloop&#33;&quot;
@btime bilinear_Basdevant_plan_doubleloop&#33;&#40;bh, vh, p&#41; setup &#61; &#40;bh &#61; similar&#40;&#36;vort_hat&#41;; vh &#61; copy&#40;&#36;vort_hat&#41;; p &#61; &#36;&#40;operators, vars, auxs, plans&#41;&#41;;</code></pre>
<pre><code class="language-julia">&#91; Info: bilinear_naive
  1.416 ms &#40;193 allocations: 8.05 MiB&#41;
&#91; Info: bilinear_auxs&#33;
  1.447 ms &#40;183 allocations: 5.54 MiB&#41;
&#91; Info: bilinear_Basdevant_brdcst
  1.171 ms &#40;160 allocations: 7.54 MiB&#41;
&#91; Info: bilinear_plan_brdcst&#33;
  906.084 μs &#40;0 allocations: 0 bytes&#41;
&#91; Info: bilin_hat_Basdevant_plan_brdcst&#33;
  739.583 μs &#40;0 allocations: 0 bytes&#41;
&#91; Info: bilinear_Basdevant_plan_loop&#33;
  705.417 μs &#40;0 allocations: 0 bytes&#41;
&#91; Info: bilinear_Basdevant_plan_doubleloop&#33;
  698.083 μs &#40;0 allocations: 0 bytes&#41;</code></pre>
<h2 id="conclusions"><a href="#conclusions" class="header-anchor">Conclusions</a></h2>
<p>Clearly, <code>bilinear_naive</code> is pretty bad, in great part because of the use of the allocating transforms <code>rfft</code> and <code>irfft</code>.</p>
<p>The method <code>bilinear_auxs&#33;</code> saves some allocations but is pretty slow as well, due to also using <code>rfft</code> and <code>irfft</code>.</p>
<p>The method <code>bilinear_Basdevant_brdcst</code> saves some time by using the Basdevant formulation, but is still quite slow because of <code>rfft</code> and <code>irfft</code>.</p>
<p>All the others are much faster, due to using the plans for the transforms and auxiliary functions to avoid allocation of temporary variable.</p>
<p>Of the nonallocating ones, the ones that use the Basdevant formulation have a clear advantage. Indeed, computing the direct and inverse Fourier transform are the most costly operation here, so reducing it from five to four makes a significant difference.</p>
<p>Of these nonallocating ones that use the Basdevant formulation, the two that use explicit loops perform better than the broadcast one, with a slight advantage for the one that uses a single loop with <code>eachindex</code> instead of a double loop.</p>
<p>If one does <a href="https://docs.julialang.org/en/v1/manual/performance-tips/index.html#man-code-warntype-1">@code_warntype</a> on them, one sees that most are clean, but there are some yellow warnings with type <code>Union&#123;Nothing, Tuple&#123;Int64, Int64&#125;&#125;</code> precisely on the two fastest ones. Yellow warnings, fortunately, tend to be harmless, as is the case here. In this case, the warning is due to the way the <a href="https://docs.julialang.org/en/v1/manual/interfaces/#Interfaces">iterator interface</a> is implemented, which returns <code>nothing</code> when the end of the iteration is reached. One can get rid of it with <code>while</code> loops, but it won&#39;t improve the performance.</p>

    <div class="navbar">
    <p id="nav">
<span id="nav-prev" style="float: left;">
<a class="menu-level-1" href="/pages/literated/benchmark_fft_plan">6.3. Benchmarking flags for FFTW plans <kbd>←</kbd></a>
</span>
<span id="nav-next" style="float: right;">
    <a class="menu-level-1" href="/pages/literated/tests_mol"><kbd>→</kbd> 7.1. Evolution via method of lines</a>
</span>
    </p>
</div>
</br></br>



<div class="page-foot">
    
        <div class="license">
            <a href=LICENSE>MIT License </a>
            <a href="https://rmsrosa.github.io">(Ricardo M. S. Rosa)</a>
        </div>
    

    Last modified: March 24, 2022. Built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>, using the <a href="https://github.com/rmsrosa/booksjl-franklin-template">Book Template</a>.
</div><!-- CONTENT ENDS HERE -->

      </div> <!-- .books-content -->
    </div> <!-- .books-container -->

    
        <script src="/libs/katex/katex.min.js"></script>
        <script src="/libs/katex/auto-render.min.js"></script>
        <script>renderMathInElement(document.body)</script>
    

    
        <script src="/libs/highlight/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>
    

  </body>
</html>
